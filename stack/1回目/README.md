## 1. Validate Parentheses
### 思考したこと

- 条件
    - 開き括弧は同じ種類の閉じ括弧によって閉じられる。
    - 開き括弧は正しい順序で閉じられる。
- 処理のイメージ
    - 括弧が閉じられた時には括弧の組み合わせを取り出すという処理を行い続けると、本当に正しい順序で括弧が閉じられている場合は
取り出し元のデータには何も残らないという状態になる。

- 実装方針
    - 括弧の組み合わせを用意する
    - 閉じ括弧がきた場合、対応する開き括弧がひとつ前にあるのか確認し、組み合わせ通りであれば取り出し
### 考慮不足
- stackが空になった時にappendする必要があったこと

## 2. Min Stack
### 思考したこと

## 3. Evaludate Reverse Polish Notation
### 思考したこと
- 条件
    - 整数同士の割り算は切り捨て
    - tokensには「"+", "-", "*", "/"」と-100 ~ 100までの文字列しか入らない。
- 逆ポーランド記法について
    - 記号が来たタイミングで手前の数字の計算を行うという処理の繰り返しをおこなっている
### 実装方針
- tokensの配列を線形探索する
- 計算方法について
    - 数字がくればstackに押し込む
    - 記号が来れば、stackから数字を取り出して計算する。

## 4. Generate Parentheses
### 思考したこと
- N組の括弧が順番通りに、開いて閉じるパターンを全て列挙する必要がある。
    - bit全探索で可能
- Nの制約は1 <= N <= 7なので、各パターンの長さは2<= x <= 14となる。
- 正しい順番の括弧の法則とは
    - 必ず先に開き括弧のほうが前に来る
        - i番目の時点で"("の数の方が")"の方が多い状態である。
- 正しい順番の括弧のパターンについて
    - パターン数
        - "("または")"のどちらかにするだけなので 2^2 <= p <= 2^14となる。
    - 全体の内、正しい順番の括弧の法則に当てはまるパターンのみ出力すればいい。
- bit全探索で括弧のパターンを全て列挙し、当てはまるもの抽出する。
    - 括弧はとりあえず追加していき、正しい順番の括弧になっているかをチェックし正しければ答えの配列に追加する。
    - 正しさのチェックは、"("が出れば、+1し、")"が出れば-1の演算を行う用の変数を1つ用意し、0未満になった時点で正しい順番でないことは自明なので、次のパターンのチェックを行う。
- 再帰でも実装できそう。
### 実装方針
- 全パターンを洗い出す
- その内、 正しい順番の括弧パターンになっているもののみ答えとして扱う。

## 4. Daily Temperatures
### 思考したこと
i日目に観測した気温を表すint型配列のtemperaturesが与えられる。
今回の問題では、temeperatures[i]より高い気温は何日後に現れるかを答える必要がある。もし、temperatures[i]より高い気温が後続になければ0とする。

- 条件
    - 順序に意味があるのでソートはできない
    - temperaturesの長さは最小1, 最大1000
    - temperaturesの値は最小1, 最大100
    - 比較対象の2点は1点を固定し(iとする)、もう1点はi ~ len(temperatures) - 1までを探索すればいい。
    - 終了条件はtemperatures[i]より大きい最初の気温が観測された日、または最終日まで確認したらOK
- 愚直解
    - 全探索：O(N^2)でmax(temperatures[i], temperatures[j]) (i < j)を求めればいいが、今回は高速化を考える。
- 高速化
    - 比較対象元、比較対象を操作して線形探索を行う。
### 実装方針
- 比較対象元の位置を固定し、記録しておく（i）
- i番目より後ろで比較対象元より高い気温を探索する。(随時、stackにpushしていく)
    - 高い気温が見つかった場合、何日後か記録する
    - 見つからなかった場合、0とする
- 探索が終了したら、開始位置までpopする

### 考察ミス
- 比較対象元より気温が高い日が数日後に出る場合の対処法
何日後に高い気温が出るのかわかったものから順にstackから排除することで、分かってないものだけがstackに残る状態になる。
- 上記の処理を行うことでstack内は常に降順になっている。

### 解答を見た上で
- 先に何日後に気温が高くなるか分かっているものからstack処理していく。
- 何日後かを確認するには[気温, 日にち(index)]の情報が必要になる。
- スタックを積み上げていく中で、スタックの一番上にある要素が、その後に出てくる要素と比較して何かしらの条件を満たすかどうかの判定をおこなっていたい時にスタックが使用できる。
- 後から出てくるデータとの比較による条件判定や解を出すために残しておきたいものだけを保持すればいい時に使用できるデータ構造

## 5. Car Fleet
### 思考したこと
position[i], spped[i]はi番目の車がhighway上のどの位置にどのスピードで走っているのかを示している。

- 条件
    - 車は前の車を追い越さない。前の車に到達すれば、同じスピードになる。
        - 時速1kmの車Aと時速4kmの車Bがあり、車Bが車Aに追いついた時、車Bは時速4km -> 1kmになる
    - 追いついた場合は同じ車列の一部と見なされるので、車Aに車Bが追いついて目的地に到着した場合、それは1とカウントする。
    - 全ての車の位置はバラバラ（unique）
    - 車列が何組あるかわかればいいだけなので、車の順序(i番目の車)については気にしなくていい。
- 目的地に到達したらどうなるか
    - 今のposition[i]から時速spped[i]でtargetまで行くのにどれぐらいの時間がかかるのが分かる状態
- 車に追いついているかどうか
    - 目的地に到着するまでの時間が同じ -> 目的地に到着するまでの時間が同じ車が何組あるのかを調べれれば、答えがわかる。
    - 途中で追いつくと速度が変わることに注意が必要。
- 到着するまでの時間を調べるには
    - 時間 = 距離 ÷ 速さ = (target - position[i]) / speed
- 位置、targetまでの到達時間を用いて、iとi+1番目の到達時間を比較し、targetまでの間に追いつく場合は1まとまりと考えるという方法をとった。しかし、これは追いついてから時速が変わるという条件を無視することになるので誤りである。
### 解説を見た上で
考察として到達時間で比較していけばいいことは分かったが、targetに近い側の位置から比較していけばいいという考察ができていなかった。0側から比較してしまうと、後々速度の変化の可能性があることを考慮に入れれない比較になるが、target側に近い方だと速度の変化を踏まえた上で比較できる。