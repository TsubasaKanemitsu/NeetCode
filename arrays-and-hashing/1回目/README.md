## 1. Duplicate Integer
### 問題の把握
配列内のint型の値の内、重複したものがあれば```true```を返し、1つもなければ```false```を返す必要がある。

### 不明な点
この配列の最大の長さはどれぐらいになるか。
10 ^ 3以上の長さの場合、全探索では時間制限に引っかかるため、確認する必要がある。

### 解答手順
- 全探索が可能な場合：O(N^2)
    - 全探索で重複した値を探索する
- 全探索が不可能な場合：O(N)
    - 配列の値をKeyとし、出現回数をValueとしてカウントする辞書を用意する。
    - 出現回数が2回以上のものがあるかどうかを確認する。

### 思いつかなかった解法
- ソートして、隣接する値同士を比較し、重複していればtrueを返す：O(NlogN)
- ソートして、隣接する値同士を比較し、同じであればHashに値を追加する。Hashには重複した値しか存在していないので、if文で値が存在するかを確認する：O（N）

### 思いつかなかった理由
- 値を変形できるかどうかを確認していなかった

## 2. Valid Anagram
### 問題の把握
- アナグラムとはある文字列と順番は異なるが同じ文字から構成される文字列のことである
- 2つの文字列が与えられ、それらがアナグラムであるかを判定する
### 不明な点
- 文字数の制限
- 与えられる文字数は同じであるかどうか
    - アナグラムなので与えられる文字数が異なる時点でアナグラムでないと判断できる。
### 解答手順
- パターン1：与えられた文字列のそれぞれの文字数をカウントし、文字数が一致するか確認すればいい。：O(N)
- パターン2：ソートして、文字列を比較し、異なればアナグラムでない。最後まで同じであればアナグラムである。O（NlogN）←ソート関数の計算量次第

## 3. two sum
### 問題の把握
与えられたint型配列の内、異なる位置にある値の合計が与えられた値（target）であるかどうかを確認し、存在すればその組み合わせの添字を返す。
### 不明な点
特になし
### 解答手順
- 全探索（2重ループ）：O（N^2）
    - nums[i] + nums[j], i != jの条件で全探索してtargetの値になるかを確認する。
- HashMap：O(N)
    - target - nums[i]となる値が登録済みかどうかを判定し、登録されていない場合はnums[i]をhashMapに登録していく。
    - target - nums[i]となる値が登録済みであるということは、そのようなnums[j]が既に存在していたということである。

### わからなかった点
nums[i], target - nums[i] == nums[j]が存在するかどうかの判定をする際に、
nums[i]をどのように保持しておくべきかがわかっていなかった。
今回の処理では、target - nums[i]という値が存在していることがわかった時点で処理が終了するということがわかっていたので、
target - nums[i]が存在しない場合にnums[i]を登録するという風に思いつくべきだった。

## 3. group anagram
### 問題の把握

### 不明な点
すでに登録済みなのかどうかの管理方法。
文字構成の比較方法。

### 考察
#### 愚直解
アナグラムとは同一の文字構成で作成できる文字列のこと。例えば、carraceとracecar
今回の問題では、複数の文字列が渡されるので、同じアナグラムになるものをグルーピングする必要がある。

各文字列の文字構成を検査するには、O(len(文字数))となる。
今回の制約では、文字列の最大長は100なのでO(10^2)である。
与えられた全ての文字列の数の最大数は1000なので全ての文字列の文字構成を検査するには、
O(10^5)となる。

あとは文字構成の比較を行い、構成が同じものをグルーピングして出力すればいい。

愚直解だとO(10^8)になりそうなので断念。

#### 文字列ソート
各文字列をソートし、同じ文字列になるものをグルーピングする。
計算量はO(MNlogN)

### わからなかった点
- アナグラムであるかどうかを見分けるには文字数のカウントを行い、それを比較すればいいのだが、文字数カウントした値をhashMapのキーとして使用するアイデアを活かすことができなかった。

### メモ
- 値の変形
    - ソート
    - 文字数カウント

## 4. Top K Frequent Elements
### 問題把握
与えられたint型配列のnumsの中でK番目までの出現頻度が多い数値と出現回数を出力する

### 考察
#### 制約
    - numsの長さは1 <= x <= 10^4
    - -1000 <= nums[i] <= 1000
    - 1 <= k <= nums内のユニークな数字の個数

#### 愚直解：O(NlogN)
- nums内の数字の出現回数をhashMap（key=数字,value=出現回数）で管理する：O（N）
- 辞書を[数字、出現回数]の2次元配列にして、降順にソートする：O（NlogN）
- K番目までの数字と出現回数を表示する。

### 別解（nums[i]のカウント方法の変形）：O（NlogN）
2✖️10^3+1の配列で[数字、出現回数]という形で持ち、ソートすることで、出現頻度が多いK番目までの値を出力することができる。

### わからなかった点
NlogNより高速化するには、ソートせずにk番目までの出現回数の数字が何であるかわかる必要があった。
今回の場合、配列のインデックスの値を出現回数と見立てて、値を管理すべきであった。
そうすれば、最後尾から線形探索することで、K番目までの最大値を求めることができる。

## 5. Encode and Decode Strings
### 問題の把握
与えられた文字列のリストを1つの文字列となるようにエンコードし、エンコードした文字列を再度分割して、元の文字列の戻す。

### 考察
エンコードの際に元の文字列の区切りがどこになるかを保存しておく必要がある。

### わからなかった点
#### 文字列間を区切る方法の注意点
単なる文字列のみであれば、デコード時に正しくデコードされないことがある。例えば、["code", "test"]とあった場合に区切り文字として"#"を使うとする。1文字で表すと"code#test"となり、この状態で"#"を区切り文字としてデコードすると["code", "test"]とすることができる。一方で、["code", "te#st"]という文字列だった場合、1文字で表すと"code#te#st"となり、"#"でデコードすると["code", "te", "st"]となり、元通りにデコードできなくなってしまう。
今回の問題では、各文字列が続く文字数と文字列の開始を表す文字の組み合わせを各単語の前につけることで、1単語がどこまで続くのかを把握することができ、デコード時のミスを避けることができる。

#### ポインタの更新方法
while文での開始、終了位置の更新方法

## 6. Product of Array Except Self
### 問題の把握
- 与えられたnums配列において、output[i]はnums[i]を除くnumsの全要素の席である配列のoutputを返す
- 割り算を使用せずにO(N)で求められるかどうか
### 考察
- nums[i]以外のみの積が必要
- 累積の積を使用できそう
- iを左右から挟み込むように累積の積がわかれば、O(N)でnumsを線形探索した時に、O(1)でnums[i]の時のそれ以外での積を求められる。
#### 愚直解：O(N^2)
numsのの長さの制約は2 <= nums.length <= 1000なのでi==jの時以外の積を求めるように2重ループで求めることは可能である。

#### 高速化（1）　割り算を使用する場合
i==j以外の時の積ということは、numsの要素の全ての積の結果に対して、nums[i]で割れば良さそうだが、今回は割り算を使用しない方針なのでボツ。

#### 高速化（2）　挟み込み：O(N)
今回の問題は、nums[i]以外の積を求めたい。
その場合、nums[i]を選択したときにそれ以外の積がわかっている状態にしておきたい。
nums[i]以外の積は、nums[0] ~ nums[i - 1]の積とnums[i+1] ~ nums[len(nums) - 1]の積で求めることができる。
nums[i]以外の積はnums[i]の左右累積の積を求めておくことでO(1)で計算することが可能になる。
よって、O(N)で計算可能である。

## 7. Valid Sudoku
### 問題の把握
与えられた9x9の行列が有効であるかどうかを判定する。
有効であるとは、
- 1行の中に、1 - 9の数字が重複なく含まれている
- 1列の中に、1 - 9の数字が重複なく含間れている
- 9つの3x3の部分行列には、1 - 9の数字が重複なく含まれている
### 考察
- 行と列に重複がないかは、各数字の出現頻度をカウントして確認すればいい
    - setで管理し、すでに存在しているものが出現することを確認したらfalseを返せばいい
- サブボックスの重複についても同様

### わからなかった点
- 9x9の行列を3x3の行列に置換する方法
    - 各インデックスに対して、3で割ることでインデックスの置換は可能であった。

## 8. Longest Consecutive Sequence
### 問題の把握
与えられた要素の差分が連続的に1になる値の最大長はいくつになるか。
O(N)で求めたい。
### 考察
- 差分を確認したいので重複は圧縮しても問題ない。
- 差分を見るために、昇順にソートする必要があるがO(N)で収めないといけない。

バケットソートで出現した数値を管理し、連続して数値が出現している数の最大を求めればいい。と思ったが、nums[i]の制約が -10^9 <= x <= 10^9なので断念

普通にソートを使用するとO(NlogN)になるので断念。

- 連続して差分が1となる最大長の数え方
    - 最大を管理する変数が必要
    - 連続数をカウントする変数が必要
    - 連続数をリセットする処理が必要

### わからなかった点
- 連続する数値を数える方法
今回重要なのは連続した数が始まる開始位置を見つけることである。
開始位置は1つ前の数字が存在せず、次の数字が存在している状態である。
この状態を見つけたら、1ずつインクリメントし、連続する数をカウントする。
開始位置でなければ次のnums[i]が開始位置の数字かを判断するということを確認していけばいい。
## テクニック
- バケットソート
    - 通常：インデックスを与えられた数値と見立てて、数値を配列に格納することでソートが可能
    - 分布（頻度）数えソート：インデックスを頻度に見立てて、数値を配列に格納することで
- アナグラム
    - 文字列の順序ではなく、文字の出現回数が肝
    - 文字列を変形しての管理
        - 出現頻度をキーにして、hashMapで管理する
        - 文字列をソート