## 1. Duplicate Integer
### 問題の把握
配列内のint型の値の内、重複したものがあれば```true```を返し、1つもなければ```false```を返す必要がある。

### 不明な点
この配列の最大の長さはどれぐらいになるか。
10 ^ 3以上の長さの場合、全探索では時間制限に引っかかるため、確認する必要がある。

### 解答手順
- 全探索が可能な場合：O(N^2)
    - 全探索で重複した値を探索する
- 全探索が不可能な場合：O(N)
    - 配列の値をKeyとし、出現回数をValueとしてカウントする辞書を用意する。
    - 出現回数が2回以上のものがあるかどうかを確認する。

### 思いつかなかった解法
- ソートして、隣接する値同士を比較し、重複していればtrueを返す：O(NlogN)
- ソートして、隣接する値同士を比較し、同じであればHashに値を追加する。Hashには重複した値しか存在していないので、if文で値が存在するかを確認する：O（N）

### 思いつかなかった理由
- 値を変形できるかどうかを確認していなかった

## 2. Valid Anagram
### 問題の把握
- アナグラムとはある文字列と順番は異なるが同じ文字から構成される文字列のことである
- 2つの文字列が与えられ、それらがアナグラムであるかを判定する
### 不明な点
- 文字数の制限
- 与えられる文字数は同じであるかどうか
    - アナグラムなので与えられる文字数が異なる時点でアナグラムでないと判断できる。
### 解答手順
- パターン1：与えられた文字列のそれぞれの文字数をカウントし、文字数が一致するか確認すればいい。：O(N)
- パターン2：ソートして、文字列を比較し、異なればアナグラムでない。最後まで同じであればアナグラムである。O（NlogN）←ソート関数の計算量次第

## 3. two sum
### 問題の把握
与えられたint型配列の内、異なる位置にある値の合計が与えられた値（target）であるかどうかを確認し、存在すればその組み合わせの添字を返す。
### 不明な点
特になし
### 解答手順
- 全探索（2重ループ）：O（N^2）
    - nums[i] + nums[j], i != jの条件で全探索してtargetの値になるかを確認する。
- HashMap：O(N)
    - target - nums[i]となる値が登録済みかどうかを判定し、登録されていない場合はnums[i]をhashMapに登録していく。
    - target - nums[i]となる値が登録済みであるということは、そのようなnums[j]が既に存在していたということである。

### わからなかった点
nums[i], target - nums[i] == nums[j]が存在するかどうかの判定をする際に、
nums[i]をどのように保持しておくべきかがわかっていなかった。
今回の処理では、target - nums[i]という値が存在していることがわかった時点で処理が終了するということがわかっていたので、
target - nums[i]が存在しない場合にnums[i]を登録するという風に思いつくべきだった。

## 3. group anagram
### 問題の把握

### 不明な点
すでに登録済みなのかどうかの管理方法。
文字構成の比較方法。

### 考察
#### 愚直解
アナグラムとは同一の文字構成で作成できる文字列のこと。例えば、carraceとracecar
今回の問題では、複数の文字列が渡されるので、同じアナグラムになるものをグルーピングする必要がある。

各文字列の文字構成を検査するには、O(len(文字数))となる。
今回の制約では、文字列の最大長は100なのでO(10^2)である。
与えられた全ての文字列の数の最大数は1000なので全ての文字列の文字構成を検査するには、
O(10^5)となる。

あとは文字構成の比較を行い、構成が同じものをグルーピングして出力すればいい。

愚直解だとO(10^8)になりそうなので断念。

#### 文字列ソート
各文字列をソートし、同じ文字列になるものをグルーピングする。
計算量はO(MNlogN)

### わからなかった点
- アナグラムであるかどうかを見分けるには文字数のカウントを行い、それを比較すればいいのだが、文字数カウントした値をhashMapのキーとして使用するアイデアを活かすことができなかった。

### メモ
- 値の変形
    - ソート
    - 文字数カウント

## 4. Top K Frequent Elements
### 問題把握
与えられたint型配列のnumsの中でK番目までの出現頻度が多い数値と出現回数を出力する

### 考察
#### 制約
    - numsの長さは1 <= x <= 10^4
    - -1000 <= nums[i] <= 1000
    - 1 <= k <= nums内のユニークな数字の個数

#### 愚直解：O(NlogN)
- nums内の数字の出現回数をhashMap（key=数字,value=出現回数）で管理する：O（N）
- 辞書を[数字、出現回数]の2次元配列にして、降順にソートする：O（NlogN）
- K番目までの数字と出現回数を表示する。

### 別解（nums[i]のカウント方法の変形）：O（NlogN）
2✖️10^3+1の配列で[数字、出現回数]という形で持ち、ソートすることで、出現頻度が多いK番目までの値を出力することができる。

### わからなかった点
NlogNより高速化するには、ソートせずにk番目までの出現回数の数字が何であるかわかる必要があった。
今回の場合、配列のインデックスの値を出現回数と見立てて、値を管理すべきであった。
そうすれば、最後尾から線形探索することで、K番目までの最大値を求めることができる。

## 5. Encode and Decode Strings
### 問題の把握
与えられた文字列のリストを1つの文字列となるようにエンコードし、エンコードした文字列を再度分割して、元の文字列の戻す。

### 考察
エンコードの際に元の文字列の区切りがどこになるかを保存しておく必要がある。

### わからなかった点
#### 文字列間を区切る方法の注意点
単なる文字列のみであれば、デコード時に正しくデコードされないことがある。例えば、["code", "test"]とあった場合に区切り文字として"#"を使うとする。1文字で表すと"code#test"となり、この状態で"#"を区切り文字としてデコードすると["code", "test"]とすることができる。一方で、["code", "te#st"]という文字列だった場合、1文字で表すと"code#te#st"となり、"#"でデコードすると["code", "te", "st"]となり、元通りにデコードできなくなってしまう。
今回の問題では、各文字列が続く文字数と文字列の開始を表す文字の組み合わせを各単語の前につけることで、1単語がどこまで続くのかを把握することができ、デコード時のミスを避けることができる。

#### ポインタの更新方法
while文での開始、終了位置の更新方法