## 1. Duplicate Integer
### 問題の把握
配列内のint型の値の内、重複したものがあれば```true```を返し、1つもなければ```false```を返す必要がある。

### 不明な点
この配列の最大の長さはどれぐらいになるか。
10 ^ 3以上の長さの場合、全探索では時間制限に引っかかるため、確認する必要がある。

### 解答手順
- 全探索が可能な場合：O(N^2)
    - 全探索で重複した値を探索する
- 全探索が不可能な場合：O(N)
    - 配列の値をKeyとし、出現回数をValueとしてカウントする辞書を用意する。
    - 出現回数が2回以上のものがあるかどうかを確認する。

### 思いつかなかった解法
- ソートして、隣接する値同士を比較し、重複していればtrueを返す：O(NlogN)
- ソートして、隣接する値同士を比較し、同じであればHashに値を追加する。Hashには重複した値しか存在していないので、if文で値が存在するかを確認する：O（N）

### 思いつかなかった理由
- 値を変形できるかどうかを確認していなかった

## 2. Valid Anagram
### 問題の把握
- アナグラムとはある文字列と順番は異なるが同じ文字から構成される文字列のことである
- 2つの文字列が与えられ、それらがアナグラムであるかを判定する
### 不明な点
- 文字数の制限
- 与えられる文字数は同じであるかどうか
    - アナグラムなので与えられる文字数が異なる時点でアナグラムでないと判断できる。
### 解答手順
- パターン1：与えられた文字列のそれぞれの文字数をカウントし、文字数が一致するか確認すればいい。：O(N)
- パターン2：ソートして、文字列を比較し、異なればアナグラムでない。最後まで同じであればアナグラムである。O（NlogN）←ソート関数の計算量次第

## 3. two sum
### 問題の把握
与えられたint型配列の内、異なる位置にある値の合計が与えられた値（target）であるかどうかを確認し、存在すればその組み合わせの添字を返す。
### 不明な点
特になし
### 解答手順
- 全探索（2重ループ）：O（N^2）
    - nums[i] + nums[j], i != jの条件で全探索してtargetの値になるかを確認する。
- HashMap：O(N)
    - target - nums[i]となる値が登録済みかどうかを判定し、登録されていない場合はnums[i]をhashMapに登録していく。
    - target - nums[i]となる値が登録済みであるということは、そのようなnums[j]が既に存在していたということである。

### わからなかった点
nums[i], target - nums[i] == nums[j]が存在するかどうかの判定をする際に、
nums[i]をどのように保持しておくべきかがわかっていなかった。
今回の処理では、target - nums[i]という値が存在していることがわかった時点で処理が終了するということがわかっていたので、
target - nums[i]が存在しない場合にnums[i]を登録するという風に思いつくべきだった。

## 3. group anagram
### 問題の把握

### 不明な点
すでに登録済みなのかどうかの管理方法。
文字構成の比較方法。

### 考察
#### 愚直解
アナグラムとは同一の文字構成で作成できる文字列のこと。例えば、carraceとracecar
今回の問題では、複数の文字列が渡されるので、同じアナグラムになるものをグルーピングする必要がある。

各文字列の文字構成を検査するには、O(len(文字数))となる。
今回の制約では、文字列の最大長は100なのでO(10^2)である。
与えられた全ての文字列の数の最大数は1000なので全ての文字列の文字構成を検査するには、
O(10^5)となる。

あとは文字構成の比較を行い、構成が同じものをグルーピングして出力すればいい。

愚直解だとO(10^8)になりそうなので断念。

#### 文字列ソート
各文字列をソートし、同じ文字列になるものをグルーピングする。
計算量はO(MNlogN)

### わからなかった点
- アナグラムであるかどうかを見分けるには文字数のカウントを行い、それを比較すればいいのだが、文字数カウントした値をhashMapのキーとして使用するアイデアを活かすことができなかった。