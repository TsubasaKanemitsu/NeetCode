## 1. Valid Palindrome
### 問題の把握
与えられた文字列が前から見ても後ろから見ても同じ文字列であれば、trueを返す。
そうでなければfalseを返す。
与えられた文字列の内、アルファベットでない文字は無視して良い。

Palindrome = 回文
### 考察
#### 愚直解
- 文字列に対して可能な処理
    - 英数字のみを残す。スペースも無視する。
    - 文字列を反転可能
- 判定方法
    - 文字列を小文字に変換し、かつアルファベットのみの文字列に整理してから、前後から文字列を見た場合に同じ文字列になるかを確認する

#### メモリを削減する解法
- 左右からポインタを動かし、値が一致するかどうかを判定していく。それにより使用するメモリはO(1)のみとなる。

## 2. Two Sum II Input Array Is Sorted
### 問題の把握
int型で昇順に並んだ整数の配列(numbers)とtarget（整数）を与えられる。
配列の要素の内、2つの組み合わせがtargetと一致するものになる時のインデックスをindex1 < index2の順に出力する。
### 考察
- target = numbers[index1] + numbers[index2]となるようなindex1とindex2を求める
- numbers.lengthの範囲の制約が小さければ、bit全探索で組み合わせを求めることができそうだが、今回の制約では計算量がオーバーするので
ボツ。
- index1とindex2は重複してはいけない
- numbers[index1]とnumbers[index2]の総和であるため、numbers[i] + number[j], numbers[j] + numbers[i]の両方は求めなくていいため、(i, j)の組み合わせがわかればいい。
- 2重ループで, ```for i in range(len(numbers)), for j in range(i+1, len(numbers))```で求めることも可能。O(N^2)

### 思いつかなかった点
配列は昇順に並んでいるという特性に注意すべきであった。
最小と最大の位置を取る左右の端の総和を取りながら、
探索範囲を狭めていけば、targetに近づけていくことが可能である。
総和がtargetより大きければ、右端（値の大きい方）を左にシフトし、総和がtarget未満であれば左端（値の小さい方）を右にシフトしていけば、O（N）でtargetになる組み合わせが存在するかどうかを確認することができる。
- 実装方針
    - l < rの間、左右をシフトし続けて探索を行う
    - numbers[l] + numbers[r] > targetの場合、rをデクリメント
    - numbers[l] + numbers[r] < targetの場合、lをインクリメント
    - numbers[l] + numbers[r] == targetの場合、[l, r]を返す

## memo
- 回文の場合、左右から線形探索で操作を行うことを考える。
- 時間計算量の高速化と空間計算量の削減の両面でより良い解法を考える。