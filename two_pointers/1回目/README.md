## 1. Valid Palindrome
### 問題の把握
与えられた文字列が前から見ても後ろから見ても同じ文字列であれば、trueを返す。
そうでなければfalseを返す。
与えられた文字列の内、アルファベットでない文字は無視して良い。

Palindrome = 回文
### 考察
#### 愚直解
- 文字列に対して可能な処理
    - 英数字のみを残す。スペースも無視する。
    - 文字列を反転可能
- 判定方法
    - 文字列を小文字に変換し、かつアルファベットのみの文字列に整理してから、前後から文字列を見た場合に同じ文字列になるかを確認する

#### メモリを削減する解法
- 左右からポインタを動かし、値が一致するかどうかを判定していく。それにより使用するメモリはO(1)のみとなる。

## 2. Two Sum II Input Array Is Sorted
### 問題の把握
int型で昇順に並んだ整数の配列(numbers)とtarget（整数）を与えられる。
配列の要素の内、2つの組み合わせがtargetと一致するものになる時のインデックスをindex1 < index2の順に出力する。
### 考察
- target = numbers[index1] + numbers[index2]となるようなindex1とindex2を求める
- numbers.lengthの範囲の制約が小さければ、bit全探索で組み合わせを求めることができそうだが、今回の制約では計算量がオーバーするので
ボツ。
- index1とindex2は重複してはいけない
- numbers[index1]とnumbers[index2]の総和であるため、numbers[i] + number[j], numbers[j] + numbers[i]の両方は求めなくていいため、(i, j)の組み合わせがわかればいい。
- 2重ループで, ```for i in range(len(numbers)), for j in range(i+1, len(numbers))```で求めることも可能。O(N^2)

### 思いつかなかった点
配列は昇順に並んでいるという特性に注意すべきであった。
最小と最大の位置を取る左右の端の総和を取りながら、
探索範囲を狭めていけば、targetに近づけていくことが可能である。
総和がtargetより大きければ、右端（値の大きい方）を左にシフトし、総和がtarget未満であれば左端（値の小さい方）を右にシフトしていけば、O（N）でtargetになる組み合わせが存在するかどうかを確認することができる。
- 実装方針
    - l < rの間、左右をシフトし続けて探索を行う
    - numbers[l] + numbers[r] > targetの場合、rをデクリメント
    - numbers[l] + numbers[r] < targetの場合、lをインクリメント
    - numbers[l] + numbers[r] == targetの場合、[l, r]を返す

## memo
- 回文の場合、左右から線形探索で操作を行うことを考える。
- 時間計算量の高速化と空間計算量の削減の両面でより良い解法を考える。

## 3. 3Sum
### 問題の把握
int型配列のnumsが与えられる。
nums[i] + nums[j] + nums[k] == 0となる(nums[i], nums[j], nums[k])の組み合わせを求める。
nums[i], nums[j], nums[k]は重複してはならない。
i, j, kを表示する順番の制約はなし。
### 考察
### 愚直解：O(N^3)
i, j, kの3重ループで全探索を行えるが、nums.lengthの制約は3 <= nums.length <= 1000であるため、最大でO(10^9)となるため、ボツ。

### 高速化：O(NlogN)
ソートして、昇順に整数を並べる。
l = 左端、r = 右端としてnums[l], nums[r]を固定し（l < r）、
l + 1, r - 1のどちらかを足すことで0になるかどうかを確認する。
0にならなければ、nums[i] + nums[j] >= 0の時は、減る方向に処理を進める必要があるので
r -= 1, , nums[i] + nums[j] < 0の時は、増やす方向に処理を進めるために、l += 1として、組み合わせを見るようにしていた。


## わからなかった点
上記の高速化では、0が存在する場合の考慮ができていない。
例えば、[3, 0, -2, -1, 1, 2]が与えられた時、
ソートすると、[-2, -1, 0, 1, 2, 3]となるが、
[-2, 0, 2]の組み合わせはスキップされてしまう。
今回重要だったのは、固定する値を2つにするのではなく、
固定する値は1つで残りの2つの要素を線形探索する必要があった。
また条件として、0になるかどうかを見ればいいだけだったので左端を固定し、
右側にある値を2つ決めた時に、0になるかどうかを見ればいいということに気づく必要があった。

## 4. Container With Most Water
### 問題の把握
int型配列のheightsを与えられる。
heights[i]はi番目の高さである。
任意の2つのheightsを選んで、コンテナを形成したときに、保持できる水の最大量を求める。

### 考察
- 既知のこと
    - コンテナの容量は高さ✖️横幅で決まる。
    - 高さは任意の2つのheightsの内、小さい方の値に決まる。min(heights[i], heights[j]) (i , j)
    - 横幅は選んだ2つのheightsの位置の差分で決まる。j - i (i < j>)
    - heightsの並び替えはできない
    - 横幅は単調減少
- 未知のこと
    - 高さ✖️横幅の最大となるi, jの組み合わせ

#### 愚直解：O(N^2)
全探索を行い、高さ✖️横幅が最大となる値を求める。

#### 高速化

## メモ
- しゃくとり法の解説
    - https://qiita.com/drken/items/ecd1a472d3a0e7db8dce