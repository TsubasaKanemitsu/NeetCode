## 1. Binary Search
### 思考したこと
- 条件
    - 配列は昇順（nums）
    - 処理はO（logN）で行うこと
    - targetと同じ値を配列内から探す。
        - 存在する場合は、indexを返し、なければ-1を返す

## 2. Search a 2D Matrix
### 思考したこと
- 条件
    - m ✖️ nの行列とtargetが与えられる。
    - 各行の値は昇順に並んでいる
    - 各行の最初の値は、1つ前の行の最大値より大きい値である。
    - 処理はO(logM + logN)で済ませる必要がある。
- 求めるべきもの
    - targetの値が配列内に存在しているかを確認する
- 方針
    - 行と列に対して二分探索して、探索範囲を減らしながら値を探す必要がある。
    - 行の最初の値は前の行の値の最大値より小さいので、まずはどの行の中にtargetが含まれていそうかを探索するために、0列目の1 - M行の値に対して、二分探索を行う。どの行にありそうか決まった後は、その行の中にtargetがあるかを二分探索でチェックする。

### メモ
考察はあっていたが、実装がうまくいかなかった。
行を探索するl, rの値がどうなるかの想像がうまくいってなかった。

## 3. Koko Eating Bananas
### 問題文
整数配列 piles が与えられており、piles[i] は i 番目の山にあるバナナの数を表します。また、バナナをすべて食べるのに使える時間（時間数）を表す整数 h も与えられています。

1時間あたりに食べるバナナの数 k を決めることができます。毎時間、バナナの山を選び、その山から k 個のバナナを食べます。もし山に k 個未満のバナナしかない場合、その山のバナナをすべて食べ終えることはできますが、同じ時間内に別の山からバナナを食べることはできません。

すべてのバナナを h 時間以内に食べることができる最小の整数 k を返してください。
### 思考したこと
- 条件
    - 1時間で食べられるバナナの数であるkは可変である。
    - piles[i]を全て食べ切るのに使用する時間はpiles[i] / k （小数点以下がある場合は繰り上げ）
    - piles[i] / kの0番目から(len(piles) - 1)番目 までの総和がh以下になるときの最小のKを求めればいい。
    - kの最大はpilesの最大値でいい。
- 言い換え
    - バナナを全て食べるのに掛けてもいい時間であるhに最大限近づけるように1時間あたりにバナナを食べられる数kを設定する（探索する）
    - バナナ全てを食べるのに掛かる時間が最もhに近くするためのkを求めよ。
- 方針
    - kが取りえる最小値と最大値を設定し、二分探索を行う。
    - バナナを食べるのに掛かる時間を求め、h未満かどうかでkの大きさを変化させていく。
- 処理時間
    - 最大で 10^3 ✖️ log10 ^ 9 = 9log10✖️10^3
- 愚直解
    - pilesの長さは最大で10^3, hは最大で10 ^ 6まで許容されている。またpiles[i]は10 ^ 8まで許されているため、1時間あたりに食べるバナナの数を指定するkがどの数字であるか試行する回数は10^8までありえる。そのため、単純に全探索ではkの最小値を求めることはできない。そのため高速化が必要である。
- 高速化
    - 0 ~ len(piles) -1番目までを1時間でk個ずつ食べる場合にかかる時間であるsum(piles[i] / k)がh以下となるような最小のKを求めればいい。kの範囲の下限と上限を0, max(piles)として、後は二分探索で求めればいい。
    - 二分探索したい変数の数直線と条件に関連のある変数の数直線を示せばよりわかりやすくなる。
- 計算量
    - O(log(max(piles)) * len(piles))

## 4. Find Minumum In Rotated Stored Array
### 問題文
- ユニークな数字で構成された配列を昇順に並べていたものを何度か回転させた、配列が与えられる
    - 例えば、元は[1,2, 3, 4, 5, 6]だったものがm[3, 4, 5, 6, 1, 2]という風な形で与えらえれる。
- 配列の内、最も小さい値を出力する必要がある。
- O(N)でも答えられるが、O(logN)の方法を考えよ。
### 思考したこと
- 愚直解：O（N）
    - 最も小さい値をmin関数を用いて、更新し続ける。
- 高速化
    - ソートはO(NlogN)になるので使えない。
    - 最小値を求めるには、境界面となる位置を特定できればいい。
    - 回転しているので、一番左端と一番右端の比較は工夫が必要？
        - nums[x % 6], nums[(x+1)%6]で比較すれば右端を左端が境界面になった時に
### 解説見た上で
解法が思いつかなかった。昇順が途切れる部分の境界値の部分の条件をどのように二分探索に使用できるのか言い換えが重要であった。

与えられた配列において回転が発生している場合は、
昇順になる部分は2箇所に分けて考えることができる。
その特性を活かして、境界値を見つけるように二分探索を実施する。
[3, 4, 5, 6, 1, 2]のような配列では、[6, 1]の部分が境界値となる。
左：[3, 4, 5, 6]と右：[1, 2]の配列に分けて考えることができる。
mの位置とrの位置の値がnums[m]<=nums[r]になっていれば、
探索したい配列は左側になるので、rを左側に寄せる。上記の条件に当てはまらない場合は、右側に境界値があると考えられるので、lを右側に寄せる。

今回の問題は、配列内で昇順が途切れる境界部分をどのように探索すべきかを考える必要があった。問題の特性的に、基準点と比較した時にどのような状態であれば、左側・右側を動かすべきなのかということがわかっていれば解ける問題である。
